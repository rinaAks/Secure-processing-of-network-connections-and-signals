#include <signal.h> //для sigaction и в принципе всего, что начинается с sig

using namespace std;

//Объявление обработчика сигнала
volatile sig_atomic_t wasSigHup = 0; 
/*
sig_atomic_t - флаг. в true его меняет обработчик сигнала.
volatile информирует компилятор, что значение переменной может меняться извне
присвоение значения sig_atomic_t является атомарным, 
однажды начавшись, оно завершается до того, как может появиться другой сигнал и прервать его.
volatile с этим типом всегда используется, подробнее - https://it.wikireading.ru/1047*/
void sigHupHandler(int r) { //собственно, сам обработчик сигнала
	wasSigHup = 1;
}

int main(){
	//Регистрация обработчика сигнала
	struct sigaction sa; 
	//sigaction используется для изменения выполняемого процессом действия при получении определённого сигнала 
	sigaction(SIGHUP, NULL, &sa); //тип сигнала, новый метод обработки, старый метод
	sa.sa_handler = sigHupHandler; //указатель на функцию для обработки сигнала
	sa.sa_flags |= SA_RESTART;
	sigaction(SIGHUP, &sa, NULL); //переносим информацию из локальной структуры в ядро ос

	//Блокировка сигнала
	sigset_t blockedMask; //sigset_t - набор сигналов
	sigemptyset(&blockedMask); //sigemptyset инициализирует набор сигналов, указанный в set, и "очищает" его от всех сигналов
	//т.е. сбрасываем переменную blockedMask
	sigaddset(&blockedMask, SIGHUP); //добавляет SIGHUP к набору сигналов (уже пустому) blockedMask 
	sigprocmask(SIG_BLOCK, &blockedMask, &origMask); // изменяет список блокированных в данный момент сигналов
	//последний параметр - origMask, сюда записывается состояние исходной маски блокирования сигнала (старое состояние)
	
	//Основной цикл
	fd_set fds; //создаём множество файловых дескрипторов
	FD_ZERO(&fds); //инициализируем множество файловых дескрипторов (делаем его пустым)
	FD_SET(socket, &fds); //регистрируем в этом множестве все файловых дескрипторов, которые есть у приложения
	for(clientIt = clients.begin();clientIt != clients.end();clientIt++)
		FD_SET(*clientIt, &fds); //добавляет в мн-во файловые дескрипторы всех установленных соединений
	/*вызываем pselect(максимальное знач. файлового дескриптора, 
	мн-во файловых дескрипторов (хранит все фд)
	если pselect завершилась со значением отличным от -1 (не было ошибок), из этого множества будут исключены
	все фд, для которых возможна блокировка.
	последний аргумент - маска, с которой приложение запущено, и в которой сигхап ещё не был заблокирован
	*/
	if (pselect(maxFd + 1, &fds, NULL, NULL, NULL, origSigMask) == -1) //произошла ошибка, проанализировать errno 
		if (errno == EINTR) //pselect прервана каким-то сигналом, это ошибкой не является
			//проверяем wasSigHup
			if(wasSigHup == 1) //где-то вызывался обработчик сигнала, пришёл нужный сигнал
				wasSigHup = 0;
			//some actions on receiving the signal
		else //errno != EINTR, действительно ошибка, лучше завершить приложение
	//for the main socket and for every established connection
	if (FD_ISSET(fd, &fds)) //проверка, какие фд остались после работы pselect. если супер сокет, устанавливаем новое соединение;
	//если уже установленное соединение, пытаемся прочитать данные
	//some actions on the descriptor activity
	//можно завершать приложение после корректной обработки сигналов / получения данных (не так важно)
	//завершение: close на все сокеты


	return 0;
}
